---
import BaseLayout from "../layouts/BaseLayout.astro";
import "../styles/chessboard.css";
---

<BaseLayout title="Jugar">
  <h1 class="text-2xl font-bold mb-4">Tablero de Ajedrez</h1>

  <div class="board-wrapper">
    <div class="coords-top">
      <span>A</span><span>B</span><span>C</span><span>D</span>
      <span>E</span><span>F</span><span>G</span><span>H</span>
    </div>

    <div class="coords-left">
      <span>8</span><span>7</span><span>6</span><span>5</span>
      <span>4</span><span>3</span><span>2</span><span>1</span>
    </div>

    <div id="board" class="board"></div>
  </div>

  <script is:inline>
    // @ts-check

    /**
     * @typedef {"pawn" | "rook" | "horse" | "bishop" | "queen" | "king"} PieceType
     */

    /**
     * @typedef {{ type: PieceType, color: "white" | "black" }} Piece
     */

    window.addEventListener("load", () => {
      const board = /** @type {HTMLElement} */ (
        document.getElementById("board")
      );

      /** @type {HTMLElement | null} */
      let selectedSquare = null;

      /** @type {[number, number][]} */
      let currentLegalMoves = [];

      /** @type {"white" | "black"} */
      let currentTurn = "white";

      /** @type {(Piece | null)[][]} */
      const initialBoard = [
        [
          { type: "rook", color: "black" },
          { type: "horse", color: "black" },
          { type: "bishop", color: "black" },
          { type: "queen", color: "black" },
          { type: "king", color: "black" },
          { type: "bishop", color: "black" },
          { type: "horse", color: "black" },
          { type: "rook", color: "black" }
        ],
        Array.from({ length: 8 }, () => ({ type: "pawn", color: "black" })),
        Array(8).fill(null),
        Array(8).fill(null),
        Array(8).fill(null),
        Array(8).fill(null),
        Array.from({ length: 8 }, () => ({ type: "pawn", color: "white" })),
        [
          { type: "rook", color: "white" },
          { type: "horse", color: "white" },
          { type: "bishop", color: "white" },
          { type: "queen", color: "white" },
          { type: "king", color: "white" },
          { type: "bishop", color: "white" },
          { type: "horse", color: "white" },
          { type: "rook", color: "white" }
        ]
      ];

      const castlingRights = {
        whiteKingSide: true,
        whiteQueenSide: true,
        blackKingSide: true,
        blackQueenSide: true
      };

      /** @type {{ row: number; col: number } | null} */
      let enPassantTarget = null;

      /**
       * @param {Piece | null} piece
       * @returns {string}
       */
      function getPieceImage(piece) {
        return piece ? `/pieces/${piece.color[0]}_${piece.type}.svg` : "";
      }

      /**
       * @param {Piece | null} piece
       * @returns {boolean}
       */
      function isPieceTurn(piece) {
        return !!piece && piece.color === currentTurn;
      }

      function switchTurn() {
        currentTurn = currentTurn === "white" ? "black" : "white";
      }

      /**
       * @param {HTMLImageElement} img
       * @param {number} row
       * @param {number} col
       */
      function enableDrag(img, row, col) {
        img.addEventListener("dragstart", (e /** @type {DragEvent} */) => {
          if (!e.dataTransfer) return;
          e.dataTransfer.setData("text/plain", `${row},${col}`);
        });
      }

      /**
       * @param {HTMLElement | null} square
       */
      function highlightSquare(square) {
        const prev = board.querySelector(".selected");
        if (prev) prev.classList.remove("selected");
        if (square) square.classList.add("selected");
      }

      /**
       * @param {[number, number][]} moves
       */
      function highlightLegalMoves(moves) {
        clearLegalMoves();
        currentLegalMoves = moves;
        for (const [r, c] of moves) {
          const sq = board.querySelector(
            `[data-row="${r}"][data-col="${c}"]`
          );
          if (sq) {
            sq.classList.add("legal-move");
          }
        }
      }

      function clearLegalMoves() {
        const prev = board.querySelectorAll(".legal-move");
        prev.forEach((sq) => sq.classList.remove("legal-move"));
        currentLegalMoves = [];
      }

      /**
       * @param {(Piece | null)[][]} boardState
       * @param {"white" | "black"} color
       * @returns {[number, number] | null}
       */
      function findKing(boardState, color) {
        for (let r = 0; r < 8; r++) {
          for (let c = 0; c < 8; c++) {
            const p = boardState[r][c];
            if (p && p.type === "king" && p.color === color) {
              return [r, c];
            }
          }
        }
        return null;
      }

      /**
       * @param {(Piece | null)[][]} boardState
       * @param {number} row
       * @param {number} col
       * @param {"white" | "black"} color
       * @returns {boolean}
       */
      function isSquareAttacked(boardState, row, col, color) {
        const enemy = color === "white" ? "black" : "white";

        // Pawn attacks
        const pawnDir = enemy === "white" ? -1 : 1;
        for (const dc of [-1, 1]) {
          const r = row + pawnDir;
          const c = col + dc;
          if (r >= 0 && r < 8 && c >= 0 && c < 8) {
            const p = boardState[r][c];
            if (p && p.color === enemy && p.type === "pawn") return true;
          }
        }

        // Horse attacks
        const horseDeltas = [
          [-2, -1],
          [-2, 1],
          [-1, -2],
          [-1, 2],
          [1, -2],
          [1, 2],
          [2, -1],
          [2, 1]
        ];
        for (const [dr, dc] of horseDeltas) {
          const r = row + dr;
          const c = col + dc;
          if (r >= 0 && r < 8 && c >= 0 && c < 8) {
            const p = boardState[r][c];
            if (p && p.color === enemy && p.type === "horse") return true;
          }
        }

        // Sliding pieces
        const directions = [
          [-1, 0],
          [1, 0],
          [0, -1],
          [0, 1],
          [-1, -1],
          [-1, 1],
          [1, -1],
          [1, 1]
        ];
        for (const [dr, dc] of directions) {
          let r = row + dr;
          let c = col + dc;
          while (r >= 0 && r < 8 && c >= 0 && c < 8) {
            const p = boardState[r][c];
            if (p) {
              if (p.color === enemy) {
                if (
                  (p.type === "rook" && (dr === 0 || dc === 0)) ||
                  (p.type === "bishop" && dr !== 0 && dc !== 0) ||
                  p.type === "queen"
                ) {
                  return true;
                }
              }
              break;
            }
            r += dr;
            c += dc;
          }
        }

        // King attacks
        const kingDeltas = [
          [-1, -1],
          [-1, 0],
          [-1, 1],
          [0, -1],
          [0, 1],
          [1, -1],
          [1, 0],
          [1, 1]
        ];
        for (const [dr, dc] of kingDeltas) {
          const r = row + dr;
          const c = col + dc;
          if (r >= 0 && r < 8 && c >= 0 && c < 8) {
            const p = boardState[r][c];
            if (p && p.color === enemy && p.type === "king") return true;
          }
        }

        return false;
      }

      /**
       * @param {(Piece | null)[][]} boardState
       * @param {"white" | "black"} color
       * @returns {boolean}
       */
      function isKingInCheck(boardState, color) {
        const kingPos = findKing(boardState, color);
        if (!kingPos) return false;
        const [kr, kc] = kingPos;
        return isSquareAttacked(boardState, kr, kc, color);
      }

      /**
       * @param {number} row
       * @param {number} col
       * @param {Piece} piece
       * @returns {[number, number][]}
       */
      function getPseudoLegalMoves(row, col, piece) {
        switch (piece.type) {
          case "pawn":
            return getPawnMoves(row, col, piece.color);
          case "rook":
            return getRookMoves(row, col);
          case "horse":
            return getHorseMoves(row, col);
          case "bishop":
            return getBishopMoves(row, col);
          case "queen":
            return getQueenMoves(row, col);
          case "king":
            return getKingMoves(row, col);
          default:
            return [];
        }
      }

      /**
       * @param {number} row
       * @param {number} col
       * @param {Piece} piece
       * @returns {[number, number][]}
       */
      function getLegalMoves(row, col, piece) {
        const moves = /** @type {[number, number][]} */ ([]);
        const pseudo = getPseudoLegalMoves(row, col, piece);

        for (const [toRow, toCol] of pseudo) {
          /** @type {(Piece | null)[][]} */
          const boardCopy = [];
          for (let r = 0; r < 8; r++) {
            /** @type {(Piece | null)[]} */
            const rowCopy = [];
            for (let c = 0; c < 8; c++) {
              rowCopy.push(initialBoard[r][c]);
            }
            boardCopy.push(rowCopy);
          }

          boardCopy[toRow][toCol] = boardCopy[row][col];
          boardCopy[row][col] = null;

          if (
            piece.type === "pawn" &&
            enPassantTarget &&
            toRow === enPassantTarget.row &&
            toCol === enPassantTarget.col
          ) {
            const dir = piece.color === "white" ? 1 : -1;
            boardCopy[toRow + dir][toCol] = null;
          }

          if (!isKingInCheck(boardCopy, piece.color)) {
            moves.push([toRow, toCol]);
          }
        }

        if (piece.type === "king") {
          const castleMoves = getCastlingMoves(row, col, piece.color);
          for (const m of castleMoves) moves.push(m);
        }

        return moves;
      }

      /**
       * @param {number} row
       * @param {number} col
       * @param {"white" | "black"} color
       * @returns {[number, number][]}
       */
      function getPawnMoves(row, col, color) {
        const moves = /** @type {[number, number][]} */ ([]);
        const dir = color === "white" ? -1 : 1;
        const startRow = color === "white" ? 6 : 1;

        if (
          initialBoard[row + dir] &&
          initialBoard[row + dir][col] === null
        ) {
          moves.push([row + dir, col]);

          if (
            row === startRow &&
            initialBoard[row + 2 * dir][col] === null
          ) {
            moves.push([row + 2 * dir, col]);
          }
        }

        for (const dc of [-1, 1]) {
          const r = row + dir;
          const c = col + dc;
          if (r >= 0 && r < 8 && c >= 0 && c < 8) {
            const target = initialBoard[r][c];
            if (target && target.color !== color) {
              moves.push([r, c]);
            }
          }
        }

        if (enPassantTarget) {
          const r = enPassantTarget.row;
          const c = enPassantTarget.col;
          if (r === row + dir && Math.abs(c - col) === 1) {
            moves.push([r, c]);
          }
        }

        return moves;
      }

      /**
       * @param {number} row
       * @param {number} col
       * @returns {[number, number][]}
       */
      function getHorseMoves(row, col) {
        const moves = /** @type {[number, number][]} */ ([]);
        const deltas = [
          [-2, -1],
          [-2, 1],
          [-1, -2],
          [-1, 2],
          [1, -2],
          [1, 2],
          [2, -1],
          [2, 1]
        ];
        const piece = initialBoard[row][col];
        if (!piece) return moves;
        const color = piece.color;

        for (const [dr, dc] of deltas) {
          const r = row + dr;
          const c = col + dc;
          if (r >= 0 && r < 8 && c >= 0 && c < 8) {
            const target = initialBoard[r][c];
            if (!target || target.color !== color) {
              moves.push([r, c]);
            }
          }
        }

        return moves;
      }

      /**
       * @param {number} row
       * @param {number} col
       * @param {[number, number][]} directions
       * @returns {[number, number][]}
       */
      function rayMoves(row, col, directions) {
        const moves = /** @type {[number, number][]} */ ([]);
        const piece = initialBoard[row][col];
        if (!piece) return moves;
        const color = piece.color;

        for (const [dr, dc] of directions) {
          let r = row + dr;
          let c = col + dc;
          while (r >= 0 && r < 8 && c >= 0 && c < 8) {
            const target = initialBoard[r][c];
            if (!target) {
              moves.push([r, c]);
            } else {
              if (target.color !== color) moves.push([r, c]);
              break;
            }
            r += dr;
            c += dc;
          }
        }

        return moves;
      }

      /**
       * @param {number} row
       * @param {number} col
       * @returns {[number, number][]}
       */
      function getRookMoves(row, col) {
        return rayMoves(row, col, [
          [-1, 0],
          [1, 0],
          [0, -1],
          [0, 1]
        ]);
      }

      /**
       * @param {number} row
       * @param {number} col
       * @returns {[number, number][]}
       */
      function getBishopMoves(row, col) {
        return rayMoves(row, col, [
          [-1, -1],
          [-1, 1],
          [1, -1],
          [1, 1]
        ]);
      }

      /**
       * @param {number} row
       * @param {number} col
       * @returns {[number, number][]}
       */
      function getQueenMoves(row, col) {
        const moves = /** @type {[number, number][]} */ ([]);
        for (const m of getRookMoves(row, col)) moves.push(m);
        for (const m of getBishopMoves(row, col)) moves.push(m);
        return moves;
      }

      /**
       * @param {number} row
       * @param {number} col
       * @returns {[number, number][]}
       */
      function getKingMoves(row, col) {
        const moves = /** @type {[number, number][]} */ ([]);
        const deltas = [
          [-1, -1],
          [-1, 0],
          [-1, 1],
          [0, -1],
          [0, 1],
          [1, -1],
          [1, 0],
          [1, 1]
        ];
        const piece = initialBoard[row][col];
        if (!piece) return moves;
        const color = piece.color;

        for (const [dr, dc] of deltas) {
          const r = row + dr;
          const c = col + dc;
          if (r >= 0 && r < 8 && c >= 0 && c < 8) {
            const target = initialBoard[r][c];
            if (!target || target.color !== color) {
              moves.push([r, c]);
            }
          }
        }

        return moves;
      }

      /**
       * @param {number} row
       * @param {number} col
       * @param {"white" | "black"} color
       * @returns {[number, number][]}
       */
      function getCastlingMoves(row, col, color) {
        const moves = /** @type {[number, number][]} */ ([]);
        const kingRow = color === "white" ? 7 : 0;
        if (row !== kingRow || col !== 4) return moves;
        if (isKingInCheck(initialBoard, color)) return moves;

        if (
          (color === "white"
            ? castlingRights.whiteKingSide
            : castlingRights.blackKingSide) &&
          initialBoard[kingRow][5] === null &&
          initialBoard[kingRow][6] === null &&
          !isSquareAttacked(initialBoard, kingRow, 5, color) &&
          !isSquareAttacked(initialBoard, kingRow, 6, color)
        ) {
          moves.push([kingRow, 6]);
        }

        if (
          (color === "white"
            ? castlingRights.whiteQueenSide
            : castlingRights.blackQueenSide) &&
          initialBoard[kingRow][1] === null &&
          initialBoard[kingRow][2] === null &&
          initialBoard[kingRow][3] === null &&
          !isSquareAttacked(initialBoard, kingRow, 3, color) &&
          !isSquareAttacked(initialBoard, kingRow, 2, color)
        ) {
          moves.push([kingRow, 2]);
        }

        return moves;
      }

      /**
       * @param {number} fromRow
       * @param {number} fromCol
       * @param {number} toRow
       * @param {number} toCol
       * @param {Piece} piece
       */
      function applySpecialMoves(fromRow, fromCol, toRow, toCol, piece) {
        if (
          piece.type === "pawn" &&
          enPassantTarget &&
          toRow === enPassantTarget.row &&
          toCol === enPassantTarget.col
        ) {
          const dir = piece.color === "white" ? 1 : -1;
          initialBoard[toRow + dir][toCol] = null;
        }

        enPassantTarget = null;
        if (piece.type === "pawn" && Math.abs(toRow - fromRow) === 2) {
          enPassantTarget = { row: (fromRow + toRow) / 2, col: fromCol };
        }

        if (piece.type === "king") {
          if (piece.color === "white") {
            castlingRights.whiteKingSide = false;
            castlingRights.whiteQueenSide = false;
          } else {
            castlingRights.blackKingSide = false;
            castlingRights.blackQueenSide = false;
          }

          if (fromCol === 4 && toCol === 6) {
            initialBoard[toRow][5] = initialBoard[toRow][7];
            initialBoard[toRow][7] = null;
            movePieceDOM(toRow, 7, toRow, 5);
          }

          if (fromCol === 4 && toCol === 2) {
            initialBoard[toRow][3] = initialBoard[toRow][0];
            initialBoard[toRow][0] = null;
            movePieceDOM(toRow, 0, toRow, 3);
          }
        }

        if (piece.type === "rook") {
          if (fromRow === 7 && fromCol === 0)
            castlingRights.whiteQueenSide = false;
          if (fromRow === 7 && fromCol === 7)
            castlingRights.whiteKingSide = false;
          if (fromRow === 0 && fromCol === 0)
            castlingRights.blackQueenSide = false;
          if (fromRow === 0 && fromCol === 7)
            castlingRights.blackKingSide = false;
        }

        if (piece.type === "pawn") {
          if (piece.color === "white" && toRow === 0) {
            initialBoard[toRow][toCol] = { type: "queen", color: "white" };
          }
          if (piece.color === "black" && toRow === 7) {
            initialBoard[toRow][toCol] = { type: "queen", color: "black" };
          }
        }
      }

      /**
       * @param {number} fromRow
       * @param {number} fromCol
       * @param {number} toRow
       * @param {number} toCol
       */
      function movePieceDOM(fromRow, fromCol, toRow, toCol) {
        const fromSquare = board.querySelector(
          `[data-row="${fromRow}"][data-col="${fromCol}"]`
        );
        const toSquare = board.querySelector(
          `[data-row="${toRow}"][data-col="${toCol}"]`
        );

        if (!fromSquare || !toSquare) return;

        const pieceImg = fromSquare.querySelector("img");
        if (!pieceImg) return;

        toSquare.innerHTML = "";
        toSquare.appendChild(pieceImg);
        fromSquare.innerHTML = "";

        enableDrag(/** @type {HTMLImageElement} */ (pieceImg), toRow, toCol);
      }

      // ConstrucciÃ³n del tablero y listeners
      for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
          const square = document.createElement("div");
          square.classList.add("square");
          square.dataset.row = String(row);
          square.dataset.col = String(col);

          const isDark = (row + col) % 2 === 1;
          square.style.backgroundColor = isDark ? "#769656" : "#eeeed2";

          const piece = initialBoard[row][col];
          if (piece) {
            const img = document.createElement("img");
            img.src = getPieceImage(piece);
            img.className = "piece";
            img.draggable = true;

            enableDrag(img, row, col);

            img.addEventListener("dragstart", () => {
            const piece = initialBoard[row][col];
            if (!piece || !isPieceTurn(piece)) return;

            selectedSquare = square;
            highlightSquare(square);

            const legal = getLegalMoves(row, col, piece);
            highlightLegalMoves(legal);
          });

            square.appendChild(img);
          }

          square.addEventListener("click", () => {
            const pieceHere = initialBoard[row][col];

            if (!selectedSquare) {
              if (pieceHere && isPieceTurn(pieceHere)) {
                // Seleccionar pieza
                selectedSquare = square;
                highlightSquare(square);

                const legal = getLegalMoves(row, col, pieceHere);
                highlightLegalMoves(legal);
              }
              return;
            }

            const fromRow = Number(selectedSquare.dataset.row);
            const fromCol = Number(selectedSquare.dataset.col);
            const selectedPiece = initialBoard[fromRow][fromCol];

            if (pieceHere && isPieceTurn(pieceHere) && (fromRow !== row || fromCol !== col)) {
              selectedSquare = square;
              highlightSquare(square);

              const legal = getLegalMoves(row, col, pieceHere);
              highlightLegalMoves(legal);
              return;
            }

            if (fromRow === row && fromCol === col) {
              selectedSquare = null;
              highlightSquare(null);
              clearLegalMoves();
              return;
            }

            if (!selectedPiece) return;

            const legal = getLegalMoves(fromRow, fromCol, selectedPiece);
            const isLegal = legal.some(([r, c]) => r === row && c === col);
            if (!isLegal) return;

            initialBoard[row][col] = selectedPiece;
            initialBoard[fromRow][fromCol] = null;

            applySpecialMoves(fromRow, fromCol, row, col, selectedPiece);
            movePieceDOM(fromRow, fromCol, row, col);

            selectedSquare = null;
            highlightSquare(null);
            clearLegalMoves();
            switchTurn();
          });

          square.addEventListener("dragover", (e /** @type {DragEvent} */) => {
            e.preventDefault();
            square.classList.add("hover-target");
          });

          square.addEventListener("dragleave", () => {
            square.classList.remove("hover-target");
          });

          square.addEventListener("drop", (e /** @type {DragEvent} */) => {
            e.preventDefault();
            square.classList.remove("hover-target");

            if (!e.dataTransfer) return;

            const data = e.dataTransfer.getData("text/plain");
            const [fromRow, fromCol] = data.split(",").map(Number);

            const movingPiece = initialBoard[fromRow][fromCol];
            if (!movingPiece || !isPieceTurn(movingPiece)) return;

            const toRow = row;
            const toCol = col;

            if (fromRow === toRow && fromCol === toCol) {
              selectedSquare = null;
              highlightSquare(null);
              return;
            }

            const legal = getLegalMoves(fromRow, fromCol, movingPiece);
            const isLegal = legal.some(
              ([r, c]) => r === toRow && c === toCol
            );
            if (!isLegal) return;

            initialBoard[toRow][toCol] = movingPiece;
            initialBoard[fromRow][fromCol] = null;

            applySpecialMoves(fromRow, fromCol, toRow, toCol, movingPiece);
            movePieceDOM(fromRow, fromCol, toRow, toCol);

            clearLegalMoves();
            selectedSquare = null;
            highlightSquare(null);
            switchTurn();
          });

          board.appendChild(square);
        }
      }
    });
  </script>
</BaseLayout>
